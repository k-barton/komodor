<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is "KomodoR" code.
 *
 * The Initial Developer of the Original Code is ActiveState Software Inc.
 * Portions created by ActiveState Software Inc are Copyright (C) 2008-2009
 * ActiveState Software Inc. All Rights Reserved.
 *
 * Contributor:
 *   Kamil Barton
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** -->

<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
<!--<?xml-stylesheet href="chrome://komodor/skin/pkgman.css" type="text/css"?>-->
<?xml-stylesheet href="chrome://komodor/content/pkgman/loadbox.css" type="text/css"?>
<!--<?xml-stylesheet href="file:///c:/temp/pkgman/pkgman.css" type="text/css"?>-->
<?xml-stylesheet href="chrome://komodor/content/pkgman/pkgman.css" type="text/css"?>

<window id="RPackageManager" xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
    width="400" height="300" screenX="20" screenY="20"
    persist="screenX screenY width height"
    title="R package manager" >

<script type="text/javascript">
<![CDATA[

var sv, ko;
var pmDeck;

function JSONDecode(str) {
	var nativeJSON = Components.classes["@mozilla.org/dom/json;1"]
			.createInstance(Components.interfaces.nsIJSON);
	try {
		return nativeJSON.decode(str);
	} catch(e) {
		return null;
	}
}

function _notify(message, msgid, type, buttons) {
	var image, priority;
	var nb = document.getElementById("rPkgManNotificationBox");
	switch(type) {
		case 'question':
			image = 'chrome://global/skin/icons/question-24.png';
			priority = nb.PRIORITY_WARNING_MEDIUM;
			break;
		case 'error':
			image = 'chrome://global/skin/icons/error-24.png';
			priority = nb.PRIORITY_CRITICAL_MEDIUM;
			break;
		case 'warning':
			image = 'chrome://global/skin/icons/warning-24.png';
			priority = nb.PRIORITY_WARNING_MEDIUM;
			break;
		default:
			image = 'chrome://global/skin/icons/information-24.png';
			priority = nb.PRIORITY_INFO_MEDIUM;
	}
	//if(!buttons) {
	//	buttons = [{
	//		label: 'Ok',
	//		accessKey: 'O',
	//		popup: null,
	//		callback: function(e) nb.currentNotification.close()
	//	}];
	//}
	nb.appendNotification(message, msgid, image, priority, buttons);
}

function closeBusyNotification() {
	var nb = document.getElementById("rPkgManNotificationBox");
	var nfcBusy = nb.getNotificationWithValue("r-is-busy");
	if(nfcBusy) nfcBusy.close();
}

function pkgManInstall(pkg, ask) {
	ask = ', ask='  + (ask? 'TRUE' : 'FALSE') + ', installDeps=' +
		(ask? 'FALSE' :  'TRUE');
	var cmd = 'cat(simpsON(sv_pkgManInstallPackages("' + pkg + '"' + ask + ')))';
	sv.rconn.evalPredefined(cmd, "pkgman-install", true, pkg);
}

function _installHandler(res, pkg) {
	closeBusyNotification();
	var response = JSONDecode(res);
	if (response == null) {
		_notify('wtf' + res, "install-wtf", "info");
		return;
	} else if (response.status == "question") {
		var buttons = [{
			label: 'Ok',
			accessKey: 'O',
			callback: function(n) {
				var cmd = 'cat(simpsON(sv_pkgManInstallPackages("' + pkg +
					'", ask=FALSE, installDeps=TRUE)))';
				sv.rconn.evalPredefined(cmd, "pkgman-update-info", true, "installed");
				_notify('R is now busy installing the requested packages. ' +
						'No output will be shown in Komodo before the operation finishes.',
						'r-is-busy', 'info');
				//sv.r.evalAsync(cmd, updateInfo, "installed");
				n.close();
			}
		}, {
			label: 'Cancel', accessKey: 'C',
			callback: function(n) n.close()
		} ];
		_notify(response.message, "install-query", "question", buttons);
	} else if (response.status == "done") {
		ko.dialogs.alert("R said:", response.message, document.title);
	}
}

function pkgManRemove(pkg) {
	var cmd = 'cat(simpsON(sv_pkgManRemovePackage("' + pkg + '")))';
	//sv.r.evalAsync(cmd, updateInfo, "removed");
	sv.rconn.evalPredefined(cmd, "pkgman-update-info", true, "removed");
}

function pkgManDetach(pkg) {
	var cmd = 'cat(simpsON(sv_pkgManDetachPackage("' + pkg + '")))';
	//sv.r.evalAsync(cmd, updateInfo, "detached");
	sv.rconn.evalPredefined(cmd, "pkgman-update-info", true, "detached");

}

function pkgManUpgrade(pkg) {
	var cmd = 'cat(simpsON(sv_pkgManInstallPackages("' + pkg + '", ask=FALSE)))';
	sv.rconn.evalPredefined(cmd, "pkgman-update-info", true, "installed");
	_notify('R is now busy installing the requested packages. ' +
		'No output will be shown in Komodo before the operation finishes.',
		'r-is-busy', 'info');
}




function pkgManLoad(pkg) {
	var cmd = 'cat(simpsON(sv_pkgManLoadPackage("' + pkg + '")))';
	sv.r.evalAsync(cmd, updateInfo, "loaded");
}

function getUpdateable() {
	sv.rconn.evalAsync("sv_pkgManGetUpdateable()", populateUpdateablePkgs, true, true);
}

function populateUpdateablePkgs(rOutput) {
	if (!rOutput || rOutput == 'NULL') return;
	document.getElementById("rUpdateableLoadBox").loaded = true;
	rl = document.getElementById("rUpdateableList");
	var res = sv.io.csvToObj(rOutput, ';;', 0, true,
		['package', 'libPath', 'version', 'rVersion', 'reposVersion', 'repos' ]);

	while(rl.itemCount) rl.removeItemAt(0);
	var item;
	for(var i = 0, l = res.length; i < l; i++){
		item = res[i];
		rl.appendChild(makePkgItem(item.package, item.reposVersion, item.repos,
			item.version, "old", true, true, false));
	}
}


function updateInfo(res, what) {
// add to installed / reload installed
// update items in Available
// remove from Updates
	closeBusyNotification();

	var avpList = document.getElementById("rAvailablePackageList");
	var instList = document.getElementById("rPackageList");

	switch(what) {
	case "installed":
		response = JSONDecode(res);
		if(response == null) {
			_notify(res, what, "warning");
			return;
		}

		var pkgs = response.packages;
		if (typeof pkgs == "string") pkgs = [pkgs];

		var msg = response.message.join("\n").trim();

		_notify("Installation of " + pkgs.join(', ') + " finished." +
				(msg? " See output in console for details." : ""),
				what, "info");
		if(msg) sv.cmdout.print(msg);

		var packageName, items;

		for(var i in pkgs) {
			packageName = pkgs[i];

			items = avpList.getElementsByAttribute("label", packageName);
			if(items.length == 0) continue;
			for(var j = 0; j < items.length; j++) {
				items[j].setAttribute("installedVersion", items[j].getAttribute("version"));
				items[j].setAttribute("installed", true);
			}
		}
		getInstalledPkgs();
		break;
	case "removed":
		response = JSONDecode(res);
		if(response == null) {
			//ko.dialogs.alert("Something went wrong...", res, document.title + " updateInfo");
			_notify(res, what, "error");
			return;
		}
		var items, changedCount = 0;
		for(var packageName in response) {
			if(response[packageName] == "TRUE") {
				changedCount++;
				items = avpList.getElementsByAttribute("label", packageName);
				if(items.length == 0) continue;
				for(var j = 0; j < items.length; j++) {
					items[j].removeAttribute("installed");
					items[j].setAttribute("installedVersion", "");
				}
			}
		}
		if(changedCount > 0) getInstalledPkgs();
		break;
	case "loaded":
		getInstalledPkgs();
		response = JSONDecode(res);
		var notification = '';
		if(response == null) {
			notification = sv.translate("See output in console for additional information.");
			sv.cmdout.print(res);
		} else {
			var status = response.status;
			for(var i in status)
				if (status[i] != 'TRUE')
					notification += sv.translate("Package %S was not loaded.", i)
						+ " ";
			if(response.message) {
				sv.cmdout.print(response.message);
				notification += sv.translate("See output in console for additional information.");
			}
		}
		if(notification)
			_notify(notification, "update-loaded", "info");
		break;
	case "detached":
		response = JSONDecode(res);
		var notification = '';
		if(response == null) {
			notification = sv.translate("See output in console for additional information.");
			sv.cmdout.print(res);
		} else {
			var status = response.status;
			var items, changedCount = 0, errors = [];
			for(var packageName in status) {
				if(status[packageName] == "TRUE") {
					changedCount++;
					items = avpList.getElementsByAttribute("label", packageName);
					if(items.length == 0) continue;
					for(var j = 0; j < items.length; j++)
						items[j].removeAttribute("loaded");
				} else errors.push(packageName);
			}
			if(changedCount > 0) getInstalledPkgs();
			if (errors.length > 0)
				notification += sv.translate("These packages were not detached: %S.", errors.join(", ")) + " ";
			if(response.message) {
				sv.cmdout.print(response.message);
				notification += sv.translate("See output in console for additional information.") + " ";
			}
			if(notification)
				_notify(notification, "detach", errors.length? "warning" : "info");
		}
	default:

	}
}

function getDescriptionFor(el) {
	var pkg = el.label;
	sv.r.evalAsync('sv_pkgManGetDescription("' + pkg + '")', function(desc, el) {
		el.desc = desc;
	}, el);
};

function setCranMirror(url) {
	if(!url) url = sv.pref.getPref("CRANMirror").trim();
	try {
		sv.rconn.evalAsync("sv_pkgManSetCRANMirror(\"" + url + "\")", null, true);
		sv.pref.setPref("CRANMirror", url);
	} catch(e) {
		return;
	}
	var selectedCranMirror = document.getElementById('selectedCranMirror');
	if(selectedCranMirror) selectedCranMirror.value = url;
}

function populateCranMirrorsList(rOutput) {
	var lines = rOutput.split(/[\r\n]+/);
	var mirror = sv.pref.getPref("CRANMirror").trim();
	var rl = document.getElementById("rCRANMirrorsList");

	var res = sv.io.csvToObj(rOutput, ';', 0, false, ['name', 'url', 'countryCode' ]);

	while(rl.itemCount) rl.removeItemAt(0);
	var item, sel = -1;

	for(var i = 0, l = res.length; i < l; ++i){
		item = res[i];
		var row = document.createElement('listitem');
		row.setAttribute('value',  item.url);
		var cell = document.createElement('listcell');
		cell.setAttribute('label',  item.name);
		cell.setAttribute('image', "chrome://komodor/skin/images/flags/" +
						  item.countryCode + ".gif");
		cell.className = "listcell-iconic";
		row.appendChild(cell);
		cell = document.createElement('listcell');
		cell.setAttribute('label', item.url);
		row.appendChild(cell);
		if(item.url.indexOf(mirror) > -1) sel = i;
		rl.appendChild(row);
	}
	document.getElementById("rCRANMirrorsLoadBox").loaded = true;

	var it = rl.getItemAtIndex(sel);
	rl.scrollToIndex(sel);
	rl.ensureIndexIsVisible( sel);
	//rl.timedSelect(it , 10);
	rl.selectItem(it);
}

function getCranMirrors() {
	sv.rconn.evalAsync("sv_pkgManGetMirrors()", populateCranMirrorsList, true, true);
}

function makePkgItem(name, version, repositoryName, installedVersion, status, installed, old,
		loaded) {
	var item = document.createElement("richlistitem");
	item.setAttribute("label", name);
	item.setAttribute("version", version);
	item.setAttribute("repos", repositoryName);
	if(installedVersion) item.setAttribute("installedVersion", installedVersion);
	if(status) item.setAttribute("status", status);
	if(installed) item.setAttribute("installed", installed);
	if(old) item.setAttribute("old", old);
	if(loaded) item.setAttribute("loaded", loaded);
	return item;
}

function getInstalledPkgs() {
	sv.rconn.evalAsync("sv_pkgManGetInstalled(sep='\\x1e')", populateInstalledPkgs, true, true);
}

//sv_pkgManGetInstalled()

function populateInstalledPkgs(rOutput) {
	if (!rOutput || rOutput == 'NULL') return;

	document.getElementById("rPackageLoadBox").loaded = true;
	rl = document.getElementById("rPackageList");

	var res = sv.io.csvToObj(rOutput, '\x1e', 0, false, ['name', 'version',
		'description', 'loaded' ]);

	//alert(res.length);

	var selectedIndex, selectedItem, selectedLabel;
	selectedIndex = rl.selectedIndex;
	selectedItem = rl.getSelectedItem(0);
	if(selectedItem != null) selectedLabel = selectedItem.label;
	var isLoaded, loadedPkgs = [];

	while(rl.itemCount) rl.removeItemAt(0);
	for(var i = 0, l = res.length; i < l; ++i){
		item = res[i];
		isLoaded = item.loaded.indexOf('TRUE') == 0;
		if(isLoaded) loadedPkgs.push(item.name);
		rl.appendChild(makePkgItem(item.name, item.version, null, null, null,
			true, null, isLoaded));
	}

	if(selectedIndex != -1) {
		for (var i = 0, l = rl.itemCount; i < l; ++i)
			if(rl.getItemAtIndex(i).label == selectedLabel) {
				rl.selectedIndex = i;
				break;
			}
	}
	// update also available packages list (set 'loaded')
	rl = document.getElementById("rAvailablePackageList");
	var item;
	for (var i = 0, l = rl.itemCount; i < l; ++i) {
		item = rl.getItemAtIndex(i);
		if(loadedPkgs.indexOf(item.label) != -1)
			item.setAttribute("loaded", true);
		else item.removeAttribute("loaded");
	}
}

function getAvailablePkgs(page, reload) {
	//document.getElementById("rAvailablePackagesLoadBox").loaded = false;
	var rl = document.getElementById("rAvailablePackageList");

	if (!page) page = '';
	else if (page == "next")
		rl.scrollToIndex(0);
	else if (page == "prev")
		rl.scrollToIndex(rl.getRowCount() - 1);

	var searchPattern = document.getElementById('searchfield').value.trim();
	searchPattern = sv.string.toRegex(searchPattern);
	var cmd = 'sv_pkgManGetAvailable("' + page + '", sep="\\x1e", pattern="' +
		searchPattern + '", reload=' + (reload ? 'TRUE': 'FALSE') + ')';
	sv.rconn.evalAsync(cmd, populateAvailablePkgs, true, true);
}

function populateAvailablePkgs(rOutput) {
	if (rOutput.substr(0, 4) == "NULL") {
		_notify("Error getting the list of avaiable packages",
				'available-pkgs-error',
				'error', [{
					label: 'Try again',
					accessKey: 'T',
					callback: function(nn) {
						getAvailablePkgs("", true);
						nn.close();
					}
				}]);
		return;
	}
	var rl = document.getElementById("rAvailablePackageList");
	document.getElementById("rAvailablePackagesLoadBox").loaded = true;

	var res = sv.io.csvToObj(rOutput, '\x1e', 1, false, ['name', 'version',
		'installedVersion', 'status', 'reposName' ]);
	while(rl.itemCount) rl.removeItemAt(0);
	idx = new String(res[0]).trim().split(" ").map(function(x) parseInt(x));
	res = res[1];

	var item;
	var prevButton = document.getElementById('availablePackagesPrevButton');
	if (idx[0] > 1) {
		item = document.createElement("richlistitem");
		item.setAttribute("class", "navButton");
		item.setAttribute("oncommand", "getAvailablePkgs('prev')");
		rl.appendChild(item);
		prevButton.disabled = false;
	} else {
		prevButton.disabled = true;
	}

	for(var i = 0, l = res.length; i < l; ++i){
		item = res[i];
		rl.appendChild(makePkgItem(item.name, item.version, item.reposName,
			item.installedVersion, item.status, item.status != '',
			item.status == '1'));
	}

	var nextButton = document.getElementById('availablePackagesNextButton');
	if (idx[1] < idx[2]) {
		item = document.createElement("richlistitem");
		item.setAttribute("class",  "navButton");
		item.setAttribute("oncommand", "getAvailablePkgs('next')");
		rl.appendChild(item);
		nextButton.disabled = false;
	} else {
		nextButton.disabled = true;
	}
	var info = document.getElementById('availablePackagesInfo');
	info.value = ' Showing packages '  + idx[0] + "-" + idx[1]  + ' of ' + idx[2]
		+ ' total (from "' + res[0].name + '" to "'
		+ res[res.length - 1].name + '")'
}

function pmLoadPanel(e) {
	//var pmDeck = document.getElementById("pkgPanels");
	var loadBox = pmDeck.selectedPanel.getElementsByTagName("loadbox")[0];
	if(loadBox && !loadBox.loaded) {
		switch(loadBox.id) {
			case 'rAvailablePackagesLoadBox':
				getAvailablePkgs("first", true);
				break;
			case 'rPackageLoadBox':
				getInstalledPkgs();
				break;
			case 'rUpdateableLoadBox':
				getUpdateable();
				break;
			case 'rCRANMirrorsLoadBox':
				getCranMirrors();
				break;
			default:
		}
	}
}

function openRepositoriesWindow() {
	window.openDialog('chrome://komodor/content/pkgman/repositories.xul',
		"pkgManRepositories", 'all=no,modal,resizable,width=400,height=400');
}

function init() {
	sv.rconn.defineResultHandler("pkgman-install", _installHandler, false);
	sv.rconn.defineResultHandler("pkgman-update-info", updateInfo, false);

	setCranMirror();
	//getCranMirrors();
	//getAvailablePkgs("first", true);
	//getInstalledPkgs();
	pmDeck.addEventListener("select", pmLoadPanel, true);
	pmLoadPanel();
}

function pkgMgrOnLoad(event) {
	var p = parent;
	while (p = p.opener) {
		if (p.ko) {
			sv = p.sv;
			ko = p.ko;
			break;
	}}
	pmDeck = document.getElementById("pkgPanels");
	document.getElementById("viewGroup").selectedIndex =
		pmDeck.selectedIndex;

	//if(sv.r.isRunning) window.setTimeout(init, 1);
	if(sv.r.isRunning) init();
	else {
		ko.dialogs.alert("R must be started to manage its packages.",
						 null, "R package manager");
		self.close();
	}
}

addEventListener("load", pkgMgrOnLoad, false);

]]>
</script>
<hbox id="topStackBar">
	<radiogroup id="viewGroup" orient="horizontal" flex="2">
		<radio id="search-view" label="Available" accesskey="A"
			oncommand="pmDeck.selectedIndex = 0;"/>
		<radio id="extensions-view" label="Installed" accesskey="I"
			oncommand="pmDeck.selectedIndex = 1;"/>
		<radio id="updates-view" label="Updates" accesskey="U"
			oncommand="pmDeck.selectedIndex = 2;"
			   disabled="false" />
		<radio id="mirrors-view" label="CRAN mirrors" accesskey="m" selected="true"
			oncommand="pmDeck.selectedIndex = 3;"/>
	</radiogroup>
	<spacer/>
	<vbox>
	<hbox>
		<toolbarbutton id="rPkgMan"
			buttonstyle="pictures" type="menu"
			label="Tools"
			image="chrome://fugue/skin/icons/gear.png"
			style="-list-style-image: url('chrome://fugue/skin/icons/gear.png');"
			orient="horizontal" class="project-tools-icon">
		<menupopup>
			<menuitem label="Install package from local file" />
			<menuitem label="Set repositories" oncommand="openRepositoriesWindow()" />
			<menuitem label="Attach workspace" />
		</menupopup>

		</toolbarbutton>
		<!--<toolbarbutton id="placesSubpanelProjectsTools_SPV"-->
		<!--	buttonstyle="pictures" type="menu"-->
		<!--	label="Install package from local file"-->
		<!--	image="chrome://fugue/skin/icons/gear.png"-->
		<!--	style="-list-style-image: url('chrome://fugue/skin/icons/gear.png');"-->
		<!--	orient="horizontal" class="project-tools-icon"-->
		<!--	popup="placesSubpanelProjectsToolsPopup_SPV"/>-->
	<button label="Close" onclick="self.close();"/>
</hbox>
	</vbox>
</hbox>

<notificationbox id="rPkgManNotificationBox" flex="1">
<deck id="pkgPanels" flex="1" persist="selectedIndex" selectedIndex="1">
<box>
	<loadbox id="rAvailablePackagesLoadBox" flex="1" loaded="false">
		<vbox id="rAvailablePackages" flex="1" >
			<hbox id="searchPanel" align="center">
				<textbox id="searchfield" emptytext="Search packages" type="search"
						 searchbutton="true" class="compact"
						 oncommand="getAvailablePkgs('current')" />
				<toolbarbutton id="rPkgManButton-RefreshAvailable"
							buttonstyle="pictures" type="image"
							label="Reload list"
							image="chrome://fugue/skin/icons/arrow-circle-double-135.png"
							orient="horizontal" class="project-tools-icon"
							oncommand="getAvailablePkgs('first', true)" />
				<spacer flex="1"/>
				<button label="Prev" id="availablePackagesPrevButton"
						oncommand="getAvailablePkgs('prev')" />
				<button label="Next" id="availablePackagesNextButton"
						oncommand="getAvailablePkgs('next')" />
			</hbox>
			<hbox>
				<label id="availablePackagesInfo" value="" />
			</hbox>
			<hbox flex="1">
				<richlistbox id="rAvailablePackageList" class="rPackageList" flex="1" />
			</hbox>
		</vbox>
	</loadbox>
</box>
<box>
	<hbox flex="1">
		<loadbox id="rPackageLoadBox" flex="1" loaded="false">
			<richlistbox id="rPackageList" class="rPackageList" flex="1" />
		</loadbox>
	</hbox>
</box>
<box>
	<hbox flex="1">
		<loadbox id="rUpdateableLoadBox" flex="1" loaded="false">
			<richlistbox id="rUpdateableList" class="rPackageList" flex="1" />
		</loadbox>
	</hbox>
</box>
<vbox>
<hbox>
	<label value="Selected mirror: "/><label id="selectedCranMirror" value=""/>
</hbox>
<hbox flex="1">
<loadbox id="rCRANMirrorsLoadBox" flex="1" loaded="false">
	<listbox id="rCRANMirrorsList" suppressonselect="false" flex="1"
			onclick="setCranMirror(this.selectedItem.value)">
		<listhead>
			<listheader label="Name" width="100"/>
			<listheader label="URL" width="150"/>
		</listhead>
		<listcols>
			<listcol flex="1"/>
			<listcol flex="1"/>
		</listcols>
	</listbox>

</loadbox>
</hbox>
</vbox>
</deck>
</notificationbox>
</window>
